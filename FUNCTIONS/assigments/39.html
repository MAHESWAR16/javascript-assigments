<script>
    //Generate nth Fibonacci term using recursion.

    // 0 1 2 3 4 5 6
    //0 1 1 2 3 5 8


    //âœ… Step 1: Understand What the Problem Wants

// For Fibonacci:

// Generate the nth Fibonacci term using recursion

// This means:

// If you ask for 1st term â†’ 0

// If you ask for 2nd term â†’ 1

// If you ask for 3rd term â†’ 1

// If you ask for 4th term â†’ 2

// If you ask for 5th term â†’ 3

// If you ask for 6th term â†’ 5
// â€¦ etc.

// So basically:

// fib(n) = fib(n-1) + fib(n-2)


// ğŸ“Œ Understanding this pattern is step 1.

// âœ… Step 2: Find the Base Case

// Every recursion must STOP somewhere, otherwise infinite loop.

// Think like this:

// â“ What is the SMALLEST input where I already know the answer?

// For Fibonacci:

// fib(1) = 0

// fib(2) = 1

// These are known facts â†’ no need to calculate further

// These become your base cases.

// âœ… Step 3: Divide the Problem Into Smaller Problems

// Think like this:

// â“ If I donâ€™t know fib(n), can I ask someone to calculate smaller ones?

// Yes:

// fib(n) = fib(n-1) + fib(n-2)


// So you break the big problem into small versions of itself.

// âœ… Step 4: Combine the Smaller Answers

// After smaller problems return values, you combine them.

// For example:

// If n = 5:

// fib(5) = fib(4) + fib(3)


// But fib(4) and fib(3) are also calculated by asking even smaller problems.

// This is how recursion naturally works.

// ğŸ”¥ Complete Logical Breakdown Example (fib(5))

// Think like this:

// You ask:

// ğŸ‘‰ â€œWhat is fib(5)?â€

// Recursion replies:
// â¡ â€œI donâ€™t know, but Iâ€™ll find fib(4) and fib(3)â€

// For fib(4):

// It again says â€”
// â¡ â€œI donâ€™t know, let me find fib(3) and fib(2)â€

// This continues until base cases (1 and 2)

// When recursion reaches:

// fib(1) â†’ 0
// fib(2) â†’ 1


// These return values start going upward like a chain.

// ğŸ” FULL RECURSION TREE (simple view)
// fib(5)
//  â”œâ”€ fib(4)
//  â”‚   â”œâ”€ fib(3)
//  â”‚   â”‚   â”œâ”€ fib(2) â†’ 1
//  â”‚   â”‚   â””â”€ fib(1) â†’ 0
//  â”‚   â””â”€ fib(2) â†’ 1
//  â””â”€ fib(3)
//      â”œâ”€ fib(2) â†’ 1
//      â””â”€ fib(1) â†’ 0


// Then combine values:

// fib(3) = 1+0 = 1
// fib(4) = 1+1 = 2
// fib(5) = 2+1 = 3

// ğŸ”¥ FINAL CODE (super simple)
// function fib(n) {
//     if(n === 1) return 0; 
//     if(n === 2) return 1;

//     return fib(n-1) + fib(n-2);
// }

// console.log(fib(5)); // 3

// ğŸ§  HOW TO THINK (THE REAL PROCEDURE)

// Here is the thinking pattern you must follow for ANY recursion problem:

// â­ 1. Understand what output you want

// Ask yourself:

// What is the problem asking?

// What is the pattern?

// â­ 2. Identify the base case

// Ask:

// For which smallest input is the answer known?

// Example:

// Sum of digits â†’ stop at 0

// Factorial â†’ stop at 1

// Reverse number â†’ stop at 0

// Fibonacci â†’ stop at 1 & 2

// â­ 3. Break the problem into smaller parts

// Ask:

// Can I solve it by solving smaller versions of the same problem?

// â­ 4. Combine the results

// Ask:

// How do I combine the smaller results to get the final result?

// â­ 5. Do NOT think about full recursion

// You NEVER think about the entire tree.
// Just think:

// What should this function return for the current input?


// Recursion automatically handles the rest.
 
    function fibterm(a)
    {
       if(a === 0)
       {
        return 0
       }
       if(a === 1)
       {
        return 1
       }
       


       return fibterm(a-1) + fibterm(a-2)
    }


 var t =   fibterm(6)
 console.log(" fibterm of 6 is =", t)
</script>